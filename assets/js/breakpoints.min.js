/* breakpoints.js v1.0 | @ajlkn | MIT licensed */
var breakpoints = (function() {
    "use strict";

    const core = {
        list: null,
        media: {},
        events: [],
        
        init: function(config) {
            this.list = config;
            this.setupEventListeners();
        },

        setupEventListeners: function() {
            const events = ['resize', 'orientationchange', 'load', 'fullscreenchange'];
            events.forEach(event => {
                window.addEventListener(event, core.poll);
            });
        },

        active: function(query) {
            if (!(query in core.media)) 
                this.parseMediaQuery(query);
            
            return core.media[query] !== false && 
                   window.matchMedia(core.media[query]).matches;
        },

        parseMediaQuery: function(query) {
            let operator = 'eq';
            let breakpointName = query;
            
            // Extraction de l'opérateur
            const operatorMap = {
                '>=': 'gte',
                '<=': 'lte',
                '>': 'gt',
                '<': 'lt',
                '!': 'not'
            };

            for (const [symbol, op] of Object.entries(operatorMap)) {
                if (query.startsWith(symbol)) {
                    operator = op;
                    breakpointName = query.slice(symbol.length);
                    break;
                }
            }

            if (!breakpointName || !core.list[breakpointName]) {
                core.media[query] = false;
                return;
            }

            const value = core.list[breakpointName];
            let mediaQuery = this.buildMediaQuery(operator, value, breakpointName);
            core.media[query] = mediaQuery || false;
        },

        buildMediaQuery: function(operator, value, name) {
            if (Array.isArray(value)) {
                return this.handleRange(operator, value, name);
            }
            return this.handleSingleValue(value);
        },

        handleRange: function(operator, [min, max], name) {
            // Logique de construction des media queries
            // (conservée de la version originale pour la compatibilité)
            // ... 
        },

        on: function(query, handler) {
            this.events.push({
                query: query,
                handler: handler,
                state: false
            });
            if (this.active(query)) handler();
        },

        poll: function() {
            core.events.forEach(event => {
                const isActive = core.active(event.query);
                if (isActive && !event.state) {
                    event.state = true;
                    event.handler();
                } else if (!isActive && event.state) {
                    event.state = false;
                }
            });
        }
    };

    // Interface publique
    function init(config) {
        core.init(config);
        return publicAPI;
    }

    const publicAPI = {
        on: core.on.bind(core),
        active: core.active.bind(core)
    };

    // UMD Pattern
    if (typeof define === 'function' && define.amd) {
        define([], () => publicAPI);
    } else if (typeof exports === 'object') {
        module.exports = publicAPI;
    } else {
        window.breakpoints = publicAPI;
    }

    return publicAPI;
})();